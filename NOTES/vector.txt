
// c++中vector使用积累

头文件 #include <vector>
声明 vector<type> vector_name;
添加元素 vector_name.push_back(element);
检查是否为空 if(vector_name.empty()){ ... }
清除数据
       (1)  vector<type>().swap(vector_name); //size归零且capacity归零
       (2)  vector_name.clear();              //size归零capacity保持不变，即内存地址还在
循环输出
       (1) for(int i=0;i!=vector_name.size();i++){
               cout<<vector_name[i]<<end;
            }
       (2) vector<type>::iterator it;
           for(it=vector_name.begin();it<vector_name.end();it++){
               cout<<*it<<endl;
           }
       (3) for(auto it=vector_name.begin();it<vector_name.end();it++){
               cout<<*it<<endl;
           }
       (4) for(int i=0;i!=vector_name.size();i++){
               cout<<vector_name.at(i)<<end;
           }
交换数据 vector<type> vec_name1,vec_name2;
        vec_name1.swap(vec_name2);

更新数据 如果vector中已经存在元素，则可以使用下标去update这个元素。
        但是如果该元素不存在，不能这样去添加元素，必须使用容器vector的push_back()成员函数
        vector<int> tmp; tmp.push_back(1); tmp[0] = 2; cout<<tmp[0]<<endl;

排序数据 对vector<int> tmp进行排序，最简单的方式：
        sort(tmp.begin(),tmp.end())，最终tmp会以从小到大的顺序排列；
        sort(tmp.begin(),tmp.begin()+4)，最终tmp的前四位数会以从小到大的顺序排列，后面的数字不变。
        较复杂的情况就是定义比较操作函数，然后当作sort的第三个参数，sort排序时将根据比较操作函数多定义的逻辑去进行排序。