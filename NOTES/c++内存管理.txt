
内存分配方式：
    c++中，内存分为5个区，分别是栈、堆、自由存储区、全局/静态存储区、常量存储区
    栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。
            栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
    堆：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，
            一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
    自由存储区：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
    全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量
                       又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
    常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

明确区分堆与栈：
    例： void f(){int* p=new int[5];}
        其中就包含了堆与栈，new的出现，即在堆中分配了一块内存资源，而指针p，分配的是一块栈内存，所以，
            此处就是在栈内存中存放了一个指向一块堆内存的指针p。
        程序执行的具体过程为：在程序会先确定在堆中分配内存的大小，调用operator new分配内存，然后返回这块内存的首地址，放入栈中。
        在这里如果要释放数组资源，不能使用delete p，而是需要写成delete []p;这是为了告诉编译器，我们删除的是一个数组，
        编译器会根据相应的cookie信息去进行释放内存的工作。

堆和栈的区别：
   (1). 管理方式不同：栈是由编译器自动管理，堆需要程序员控制，容易产生memory leak
   (2). 空间大小不同：堆的空间远远大于栈空间；
   (3). 能否产生碎片不同：堆容易产生碎片，而栈严格按照先进后出的规则；
   (4). 生长方向不同：堆的生长方向向上，即向着内存地址增加的方法；栈的生长方向向下，向着内存地址减小的方法；
   (5). 分配方式不同：堆是动态分配，没有静态分配的堆。而栈有两种分配方式：静态分配和动态分配。静态分配是编译器完成的，
                        比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，
                        他的动态分配是由编译器进行释放，无需我们手工实现。
   (6). 分配效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，
                        压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的

控制c++的内存分配：
    重载全局的new和delete操作符、为单个的类重载new[]和delete[]

常见的内存错误及其对策：
    a、内存分配为成功
    b、内存分配虽然成功，然是尚未初始化就引用它
    c、内存分配成功并且已经初始化，但操作越过了内存边界
    d、忘记释放内存，造成内存泄露
    e、释放了内存却继续使用它

指针与数组的对比：
    数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，
        其地址与容量在生命期内保持不变，只有数组的内容可以改变。
    指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。

指针参数传递内存：

杜绝"野指针"：

有了malloc/free为什么还需要new/delete

内存耗尽怎么办？

malloc/free的使用要点

new/delete的使用要点

