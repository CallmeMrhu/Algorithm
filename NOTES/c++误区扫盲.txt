
c++数组初始化的一些误区

a、基本类型数组
1、int a[5]; // 并不会默认将所有的值初始化为0，而是随机值
2、int a[5] = {0}; //全部初始化为0
3、int a[5] = {1}; //并不能全部初始化为1

上述操作遵循的是一条基本语法规则：数组初始化列表中的元素个数小于指定的数组长度时，不足的元素补以默认值。
所以第一种方式不会进行默认初始化，第二种方式可以将数组全部初始化为0，但是第三种方式只有第一个元素为1，其他的都为0。

b、对于非基本类型的数组：
    string a[5] = {"foo"},
相当于：
    string a[5] = {"foo","","","",""};

基本类似数组和非基本类型数组的另外一个区别：
    如果不明确指出初始化列表，那么基本类型是不会被初始化的（除全局变量和静态变量外），所有的内存都是“脏的”；
而类类型则会为每个元素调用默认构造函数进行初始化。


c、动态数组的初始化（在堆空间中分配，需要手动回收内存）
    int* a = new int[5];
    string* a = new string[5];
    int* a = new int[5] { 0 };
    string* a = new string[5] { "foo" };
  面几行代码遵循栈中数组的初始化规则，除此之外这里还有一个新语法：
    int* a = new int[5]();
    注意后面的一对圆括号，它的意思是使用默认值初始化整个数组，所以对于类类型来说，new string[5] 与 new string[5]()是等价的，
  都会调用默认构造函数进行初始化；但是对于基本类型就不同了，new int[5]根本不会初始化，而new int[5]() 则会使用int()的值即０进行初始化。


d、错过了初始化时机（memset误区）
    如果想在数组创建结束后再对其进行初始化，可以使用C函数memset()，但是memset的使用有个大问题，就是它只对char类型的数组管用：
    char a[10];
    memset(a,1,10); //将a中所有元素设置为1
        但是如果将上述数据类型换成int或者其他类型，就会出现问题，因为memset的内部实现是以字节为单位进行赋值的，
    int 类型大于一个字节（假设是４个），数组内存连续，如：
        int a[10];
        memset(a, 1, sizeof(a));
        将只会对前sizeof(a)即40个字节进行赋值１的操作，即给“前５个int”进行了赋值0x01010101的操作。
        如果想正确赋值，就只能循环依次初始化。
