// learn from runoob.com
1、基本语法
    标识符命名：数字、字母、下划线，其中数字不能开头
    terminal进行编译：g++ hello.cpp -o hello // -o 指定可执行程序的文件名
                     ./hello    //执行生成的可执行文件
2、数据类型
    内置数据类型：bool、char、int、float、double、void、wchar_t
    类型修饰符：signed、unsigned、short、long
    用户自定义：typedef int C

3、变量类型
    声明：extern int a,b; void foo();
    定义：int a; void foo() { ... }

4、变量作用域
    局部变量、全局变量

5、常量
    常量可以是任何的基本数据类型；
    整数常量可以是十进制、八进制、十六进制，前缀为0x或0X为十六进制,0为八进制
    整数常量可以带一个后缀，U为无符号unsigned，L表示长整数long
    还有浮点常量、布尔常量、字符常量、字符串常量
    定义常量：#define LENGTH 10
             const int LENGTH = 10;

6、修饰符类型
    signed、unsigned、long、short、const、volatile、restrict

7、存储类（这个貌似之前没有关注过～）
    存储类定义C++程序中变量/函数的范围（可见性）和生命周期，这些说明符放置在它们修饰的类型之前。
    auto：
    register：
    static：
    extern：
    mutable：
    thread_local(C++)：

8、运算符
    算术、关系、逻辑、位运算、赋值、杂项
    运算符的优先级

9、循环
    循环类型：while、for、do...while、嵌套循环
    循环控制语句：break、continue、goto

10、判断
    判断语句：if、if...else、嵌套if、switch、嵌套switch
    ？：运算符：a > 1 ? return 1:return 2;

11、函数
    函数声明：告诉编译器函数的名称、返回类型、参数
    函数定义：提供函数的实际主体
    函数调用
    函数参数：传值调用、
             指针调用（void swap(int *x, int *y){ tmp = *x }  swap(&a, &b);）
             引用调用 (void swap(int &a, int &b){ tmp = a }  swap(a,b);)
    参数的默认值 (void swap(int a=10, int b=20))
    Lambda函数与表达式 ？？？？(还不是特别了解)

12、数字
    short、int、float、double、long
    数学运算：c++中包含各种有用的内置函数，如<cmath>
    随机数生成：rand()，该函数返回一个伪随机数，生成随机数之前必须先调用srand()，
                可以使用<ctime>中的time()获取当前时间来设置srand()的种子参数

13、数组
    数组声明，需要指定元素的类型和元素的数量
    所有数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。
    声明数组、数组赋值、访问数组
    多为数组：int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}}
    指向数组的指针： double *p;double balance[10];p=balance;cout<<*p<<*(p+1)<<*(p+2)<<endl;
    传递数组给函数：void function1(int *param){...}
                  void function2(int param[10]){...}
                  void function3(int param[]){...}
    从函数返回数组：C++不允许返回一个完整的数组作为函数的参数，但是可以通过指定不带索引的数组名来返回一个
                    指向数组的指针，函数需要声明为返回指针的函数。且c++不支持在函数外访问返回的局部变量地址，因此局部变量定义为static变量
                    int *function(){ static int r[10]; ... return r;}

14、字符串
    c风格字符串：源于c语言，并在C++中继续得到支持，如char a[]="hello";或char a[6]={'h','e','l','l','o','\0'};
    在这种情况下，属于c语言风格的字符串，c++提供内置函数<cstring>，其中的常用函数有strcpy(s1,s2);strlen(s1)等；
    注意：此处的字符串，不能写成string a = "hello"，因为string不是基本的数据类型，而是c++标准库中的一个类类型。
    c++中的string类，#include<string> string a="hello";cout<<a.size()<<endl;

15、指针
    指针的值 和 指针的所指向的变量或常量 要区分
    指针是一个变量，指针的值是其所指向变量或常量在内存中的地址
    一般操作为：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值
    int var=20; int *p; p=&var;cout<<var<<p<<*p<<endl; （20，地址，20）
    c++中的Null指针：int *ptr=NULL; cout<<ptr; (输出值为 0 即地址为0)
                    用处：可以给指针初始化为NULL，在使用之前进行判断if(!ptr)，即为非空指针，已经赋值，避免访问到操作系统预留的内存空间
    c++指针的算术运算：ptr指向地址1000的整数指针，是一个32为的整数，即4个字节，若进行ptr++操作，则会指向地址1004，不是1001，
                        因为ptr每增加一次，会指向下一个整数位置，即当前位置往后移4个字节，如果ptr指向字符，则ptr++之后的地址则为1001
                     递增一个指针：变量指针可以递增，而数组不能递增，因为数组是一个常量指针：int var[3]={1,2,3};int *ptr;ptr=var;ptr++;
                     递减一个指针：ptr=&var[MAX-1];ptr--;
                     指针的比较：ptr=var;if(ptr<=&var[MAX-1]){... ptr++;}
    c++指针数组：int *ptr[MAX]; （还不是特别了解）
    c++指向指针的指针：多级间接寻址
                     int var; int *ptr; int **pptr;
                     ptr = &var; pptr = &ptr;
    c++传递指针给函数：void function(int *par){};   可以传递指针，当然也可以传递数组
    c++从函数返回指针：首先声明一个返回指针的函数；c++不支持在函数外返回局部变量的地址，所以需要将局部变量定义为static
                     int *getNumber(){ static int r[10];    return r;}

16、引用
    引用vs指针：1、不存在空引用。引用必须连接到一块合法的内存。
               2、一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
               3、引用必须在创建时被初始化。指针可以在任何时间被初始化。
    int i=17; int& r=i; //r 是一个初始化为 i 的整型引用
    把引用当作参数：void swap(int& a, int& b){...}  int a=10,b=20;swap(a,b); 引用就是别名，指向的内存地址是一样的
    把应用当作返回值：返回的引用类型值，要么属于全局变量，要么被static修饰

17、日期&时间
    c++标准库没有提供所谓的日期类型，c++继承类c语言用于日期和时间操作的结构和函数，头文件为<ctime>
    四个时间相关的类型：clock_t、time_t、size_t、tm，其中前三种都能够把系统时间和日期表示为某种整数。
    tm属于结构体类型
    活用各种日期和时间的重要函数：time()、ctime()、localtime()...
    使用结构tm格式化时间：time_t now = time(0); tm *ltm = localtime(&now); cout<<ltm->year<<endl;

18、基本的输入输出
    c++的I/O发生在流中，流是字节序列，如果字节流从设备流向内存，则是输入操作；反之为输出操作。
    I/O库头文件：<iostream>:cin,cout,cerr,clog
                <iomanip>: 该文件通过所谓的参数化的流操纵器，来声明对执行标准化I/O有用的服务
                <fstream>:该文件为用户控制的文件处理声明服务。
    <iostream>:cin、cout不多做介绍；
               cerr为标准错误流，cerr对象附属到标准错误设备，通常是显示屏，但是cerr对象是非缓冲的，且每个流插入到cerr都会立即输出
               clog为标准日志流，clog对象附属到标准错误设备，通常是显示屏，但是clog对象是缓冲的，意味着每个流插入到clog都会先存储在缓冲中，直到缓冲填满或者缓冲区刷新时才会输出
               注：在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用cerr流来显示错误消息，而其他的日志消息则使用clog流来输出。

19、数据结构
    c/c++数组允许定义可存储相同类型数据项的变量，但是结构(结构体)是c++中另一种用户自定义的可用数据类型，允许存储不同类型的数据项
    struct Book{char title[50];char author[50];char subject[50];int bood_id};
    或者 struct Book{char title[50];char author[50];char subject[50];int bood_id} book1;
    使用成员访问运算符(.)来访问结构体的成员：Book book1; cout<<book1.title<<endl;
    结构作为函数参数：传参方式和其他类型的变量或指针类似
    指向结构的指针：struct Book *struct_ptr; struct_ptr=&book1;count<<struct_ptr->title<<endl;
    typeset关键字: typedef struct{char title[50];char author[50];char subject[50];int bood_id}Book; Book boo1,boo2;

20、C++类&对象
    关键字public、private、protected可以确定类成员的访问属性；
    公共成员可以使用直接成员访问运算符 (.) 来直接访问；
    私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问；
    类成员函数：类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。
               成员函数可以定义在类定义内部，或者单独使用范围解析运算符 :: 来定义; ::可以不跟类名，表示全局数据或全局函数（即非成员函数）。
               在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。
               在类的外部使用范围解析运算符::定义该函数：char[] Book::getTitle(void){return title;}
    类访问修饰符：public：公有成员在程序中类的外部是可访问的；
                private：私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。
                         默认情况下，类的所有成员都是私有的
                protected：保护成员变量或函数与私有成员十分相似，都不能在类的外部访问；但有一点不同，保护成员在派生类（即子类）中是可访问的。
                          即子类的成员方法可以访问父类的保护成员变量
                继承：public继承：基类的public、protected、private成员的访问属性在派生类中变成了public、protected、private
                     private继承：基类的public、protected、private成员的访问属性在派生类中变成了private、private、private
                     protected继承：基类的public、protected、private成员的访问属性在派生类中变成了protected、protected、private
    类构造函数&析构函数：构造函数：类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是
                               完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。可以无参，也可以有参；
                               class Book{...}; Book::Book(char[] Title){title=Title;}
                               等价于使用初始化列表来初始化字段：class Book{...}; Book::Book(char[] Title):title(Title){...} 多个参数则用(,)分开
                       析构函数：类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面
                                加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。
                                ～Line:Line(void){...} 程序结束时自动调用
    拷贝构造函数：是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象；
                 常用于：通过使用另一个同类型的对象来初始化新创建的对象，如对象中有int，可以借助这个int来初始化拷贝构造函数中的int变量。
                        复制对象把它作为参数传递给函数；复制对象，并从函数返回这个对象。
                 如果类中没有定义拷贝构造函数，编译器会自行定义一个，类似于构造函数；如果类带有指针变量，并有动态内存分配，则必须有一个拷贝构造函数。
                 classname (const classname &obj){   //拷贝构造函数的主体，obj是一个对象引用，用于初始化另一个对象，这也就是拷贝构造函数的关键点  }
                 调用拷贝构造函数的情况：1、对象以值传递的方式闯入函数参数；xxx(obj)
                                      2、对象以值传递的方式从函数返回；  xxx(){...return obj...}
                                      3、对象需要通过另外一个对象进行初始化。classname B = A;//or classname B(A);
                 默认拷贝函数（不会处理静态数据成员，系统自动生成）、
                 浅拷贝（只对对象中的数据成员进行简单的赋值，不会考虑动态成员，浅拷贝就是内存拷贝，不会自动分配内存空间，所以遇到这种情况就需要使用深拷贝）、
                 深拷贝（涉及到内存重新分配）
    注意区分 构造函数（初始化对象）、拷贝构造函数（用已有同类对象来初始化不存在的对象）、赋值函数（用别的对象来初始化已经存在的对象）
    友元函数：类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。
             尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。友元可以是一个函数，该函数被称为友元函数；
             友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。
             如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend
             需要在类中声明友元函数：friend void methoname(object a);参数为对象。
    内联函数：内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。
             内联函数本质是用空间代替时间，内联函数一般是1-5行小函数，函数内部不允许使用循环语句和开关语句，其定义要在使用之前，类定义中的定义的函数都是内联函数，无需inline说明符。
    this指针：在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。
             this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象，注意this指针表示的是对象。
             友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针，所以友元函数需要将对象以参数的形式传递，从而访问对象的成员属性。
    指向类的指针：与所有的指针一样，您必须在使用指针之前，对指针进行初始化。
                class Book{ ... }; int mian(){...Book book1(par1,par2); Book *ptr; ptr=&book1;cout<<ptr.title;...}
    类的静态成员：使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。
                不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化。
                class Book{public: static int num; Book(par1,par2){...num++;...}}; int Book::num=0;int main(){...}
                如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。
                静态成员函数没有this指针，只能访问静态成员(变量或函数)；普通成员函数有执政，可以访问类中的任意成员。

21、继承
    基类和派生类：父类为基类、子类为派生类；与java不同，c++中一个类可以派生自多个类，即子类可以有多个父类！
                class derived-class: access-specifier base-class
                如：class rectangle:public shape {...}
    访问控制和继承：派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private
                一个派生类继承类所有的基类方法，除了1、基类的构造函数、析构函数和拷贝构造函数；2、基类的重载运算符；3、基类的友元函数。
    继承关系：当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。
             几乎不使用 protected 或 private 继承，通常使用 public 继承。
             公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，
                                基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。
             保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
             私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。
    多继承：  多继承即一个子类可以有多个父类，它继承了多个父类的特性。
              class rectangle: public shape, public paintcost{...}
             注：多继承（环状继承）：
                class D{...}; class A: public D{...}; class B: public D{...}; class C: public A, public B {...}
                这个继承会使D创建两个对象,要解决上面问题就要用虚拟继承格式: 格式：class 类名: virtual 继承方式 父类名
                class D{...}; class A: virtual public D{...}; class B: virtual public D{...}; class C: public A, public B {...}

22、重载运算符和重载函数
