// learn from runoob.com
1、基本语法
    标识符命名：数字、字母、下划线，其中数字不能开头
    terminal进行编译：g++ hello.cpp -o hello // -o 指定可执行程序的文件名
                     ./hello    //执行生成的可执行文件
2、数据类型
    内置数据类型：bool、char、int、float、double、void、wchar_t
    类型修饰符：signed、unsigned、short、long
    用户自定义：typedef int C

3、变量类型
    声明：extern int a,b; void foo();
    定义：int a; void foo() { ... }

4、变量作用域
    局部变量、全局变量

5、常量
    常量可以是任何的基本数据类型；
    整数常量可以是十进制、八进制、十六进制，前缀为0x或0X为十六进制,0为八进制
    整数常量可以带一个后缀，U为无符号unsigned，L表示长整数long
    还有浮点常量、布尔常量、字符常量、字符串常量
    定义常量：#define LENGTH 10
             const int LENGTH = 10;

6、修饰符类型
    signed、unsigned、long、short、const、volatile、restrict

7、存储类（这个貌似之前没有关注过～）
    存储类定义C++程序中变量/函数的范围（可见性）和生命周期，这些说明符放置在它们修饰的类型之前。
    auto：
    register：
    static：
    extern：
    mutable：
    thread_local(C++)：

8、运算符
    算术、关系、逻辑、位运算、赋值、杂项
    运算符的优先级

9、循环
    循环类型：while、for、do...while、嵌套循环
    循环控制语句：break、continue、goto

10、判断
    判断语句：if、if...else、嵌套if、switch、嵌套switch
    ？：运算符：a > 1 ? return 1:return 2;

11、函数
    函数声明：告诉编译器函数的名称、返回类型、参数
    函数定义：提供函数的实际主体
    函数调用
    函数参数：传值调用、
             指针调用（void swap(int *x, int *y){ tmp = *x }  swap(&a, &b);）
             引用调用 (void swap(int &a, int &b){ tmp = a }  swap(a,b);)
    参数的默认值 (void swap(int a=10, int b=20))
    Lambda函数与表达式 ？？？？(还不是特别了解)

12、数字
    short、int、float、double、long
    数学运算：c++中包含各种有用的内置函数，如<cmath>
    随机数生成：rand()，该函数返回一个伪随机数，生成随机数之前必须先调用srand()，
                可以使用<ctime>中的time()获取当前时间来设置srand()的种子参数

13、数组
    数组声明，需要指定元素的类型和元素的数量
    所有数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。
    声明数组、数组赋值、访问数组
    多为数组：int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}}
    指向数组的指针： double *p;double balance[10];p=balance;cout<<*p<<*(p+1)<<*(p+2)<<endl;
    传递数组给函数：void function1(int *param){...}
                  void function2(int param[10]){...}
                  void function3(int param[]){...}
    从函数返回数组：C++不允许返回一个完整的数组作为函数的参数，但是可以通过指定不带索引的数组名来返回一个
                    指向数组的指针，函数需要声明为返回指针的函数。且c++不支持在函数外访问返回的局部变量地址，因此局部变量定义为static变量
                    int *function(){ static int r[10]; ... return r;}

14、字符串
    c风格字符串：源于c语言，并在C++中继续得到支持，如char a[]="hello";或char a[6]={'h','e','l','l','o','\0'};
    在这种情况下，属于c语言风格的字符串，c++提供内置函数<cstring>，其中的常用函数有strcpy(s1,s2);strlen(s1)等；
    注意：此处的字符串，不能写成string a = "hello"，因为string不是基本的数据类型，而是c++标准库中的一个类类型。
    c++中的string类，#include<string> string a="hello";cout<<a.size()<<endl;

15、指针
    指针的值 和 指针的所指向的变量或常量 要区分
    指针是一个变量，指针的值是其所指向变量或常量在内存中的地址
    一般操作为：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值
    int var=20; int *p; p=&var;cout<<var<<p<<*p<<endl; （20，地址，20）
    c++中的Null指针：int *ptr=NULL; cout<<ptr; (输出值为 0 即地址为0)
                    用处：可以给指针初始化为NULL，在使用之前进行判断if(!ptr)，即为非空指针，已经赋值，避免访问到操作系统预留的内存空间
    c++指针的算术运算：ptr指向地址1000的整数指针，是一个32为的整数，即4个字节，若进行ptr++操作，则会指向地址1004，不是1001，
                        因为ptr每增加一次，会指向下一个整数位置，即当前位置往后移4个字节，如果ptr指向字符，则ptr++之后的地址则为1001
                     递增一个指针：变量指针可以递增，而数组不能递增，因为数组是一个常量指针：int var[3]={1,2,3};int *ptr;ptr=var;ptr++;
                     递减一个指针：ptr=&var[MAX-1];ptr--;
                     指针的比较：ptr=var;if(ptr<=&var[MAX-1]){... ptr++;}
    c++指针数组：int *ptr[MAX]; （还不是特别了解）
    c++指向指针的指针：多级间接寻址
                     int var; int *ptr; int **pptr;
                     ptr = &var; pptr = &ptr;
    c++传递指针给函数：void function(int *par){};   可以传递指针，当然也可以传递数组
    c++从函数返回指针：首先声明一个返回指针的函数；c++不支持在函数外返回局部变量的地址，所以需要将局部变量定义为static
                     int *getNumber(){ static int r[10];    return r;}

16、引用
    引用vs指针：1、不存在空引用。引用必须连接到一块合法的内存。
               2、一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
               3、引用必须在创建时被初始化。指针可以在任何时间被初始化。
    int i=17; int& r=i; //r 是一个初始化为 i 的整型引用
    把引用当作参数：void swap(int& a, int& b){...}  int a=10,b=20;swap(a,b); 引用就是别名，指向的内存地址是一样的
    把应用当作返回值：返回的引用类型值，要么属于全局变量，要么被static修饰

17、日期&时间
    c++标准库没有提供所谓的日期类型，c++继承类c语言用于日期和时间操作的结构和函数，头文件为<ctime>
    四个时间相关的类型：clock_t、time_t、size_t、tm，其中前三种都能够把系统时间和日期表示为某种整数。
    tm属于结构体类型
    活用各种日期和时间的重要函数：time()、ctime()、localtime()...
    使用结构tm格式化时间：time_t now = time(0); tm *ltm = localtime(&now); cout<<ltm->year<<endl;

18、基本的输入输出
    c++的I/O发生在流中，流是字节序列，如果字节流从设备流向内存，则是输入操作；反之为输出操作。
    I/O库头文件：<iostream>:cin,cout,cerr,clog
                <iomanip>: 该文件通过所谓的参数化的流操纵器，来声明对执行标准化I/O有用的服务
                <fstream>:该文件为用户控制的文件处理声明服务。
    <iostream>:cin、cout不多做介绍；
               cerr为标准错误流，cerr对象附属到标准错误设备，通常是显示屏，但是cerr对象是非缓冲的，且每个流插入到cerr都会立即输出
               clog为标准日志流，clog对象附属到标准错误设备，通常是显示屏，但是clog对象是缓冲的，意味着每个流插入到clog都会先存储在缓冲中，直到缓冲填满或者缓冲区刷新时才会输出
               注：在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用cerr流来显示错误消息，而其他的日志消息则使用clog流来输出。

19、数据结构
    c/c++数组允许定义可存储相同类型数据项的变量，但是结构(结构体)是c++中另一种用户自定义的可用数据类型，允许存储不同类型的数据项
    struct Book{char title[50];char author[50];char subject[50];int bood_id};
    或者 struct Book{char title[50];char author[50];char subject[50];int bood_id} book1;
    使用成员访问运算符(.)来访问结构体的成员：Book book1; cout<<book1.title<<endl;
    结构作为函数参数：传参方式和其他类型的变量或指针类似
    指向结构的指针：struct Book *struct_ptr; struct_ptr=&book1;count<<struct_ptr->title<<endl;
    typeset关键字: typedef struct{char title[50];char author[50];char subject[50];int bood_id}Book; Book boo1,boo2;
